![ ](./pictures/framework.png)
Easy GUI — очень мощный фреймворк с солидной оптимизацией, позволяющий создавать сложные интерфейсы за считанные секунды.
# Содержание
1. [Размещение интерфейса в мире](#размещение-интерфейса-в-мире)
2. [Параметры](#параметры)
3. [Создание страниц](#создание-страниц)
4. [Создание кнопок](#создание-кнопок)
    1. [Тег commands](#тег-commands)
    2. [Тег link](#тег-link)
5. [Немного о работе фреймворка](#немного-о-работе-фреймворка)
6. [Примеры использования](#примеры-использования)
## Размещение интерфейса в мире
Чтобы разместить интерфейс, запустите эту функцию:
```mcfunction
function gui:gui/create/place {args:{}}
```
Команде размещения доступны теги типа массив строк commands, on_change, on_close — команды, которые выполнятся при открытии, при любом изменению страницы и при закрытии соответственно.
## Параметры
Все параметры страницы из args + теги on_change, on_close будут скопированы в игрока при открытии. Функция размещения интерфейса имеет значения параметров по умолчанию. Единственный необходимый параметр — folder.
### Таблица параметров
| Параметр     | Тип данных              | Значение по умолчанию |
|:------------:|:-----------------------:|:---------------------:|
| folder       | строка                  | обязательный параметр |
| type         | число от 0 до 2         | 2                     |
| getter       | число 0 или 1           | 0                     |
| ignore_slots | массив чисел от 0 до 26 | []                    |
| components   | число 0 или 1           | 0                     |
| save         | число 0 или 1           | 0                     |
| save+        | число 0 или 1           | 0                     |
| load         | число 0 или 1           | 0                     |
| load+        | число 0 или 1           | 0                     |
### Значения параметров
#### Параметры пути
Чтобы открыть страницу, фреймворк собирает путь до неё, используя следующие параметры:
* folder — задаёт строку пути до интерфейса в сторейдже.
* type — определяет как будет выглядеть путь до страницы:
    * 0 - folder[$(page)]
    * 1 - folder$(page)
    * 2 - folder
* getter — оптимизирует пути.
    * 0 - score игрока page не будет использоваться(type=2).
    * 1 - score игрока page будет использоваться(type=0,1).
#### Параметры страницы
* ignore_slots — слоты, в которые игрок может поместить предметы.
* components — определяет будет ли массив компонентов прибавлен к предмета на странице.
* save — определяет сохранение положенных предметов.
    * 0 - вернуть положенные предметы игроку.
    * 1 - сохранить на странице.
* save+ — определяет сохранение компонентов.
    * 0 - удалить компоненты.
    * 1 - сохранить компоненты.
* load — определяет загрузку положенных предметов.
    0 - не загружать.
    1 - загрузить.
* load+ — определяет загрузку компонентов.
    0 - не загружать.
    1 - загрузить.

Параметры type, getter, components, save, save+, load, load+ копируются в одноимённые скорборды игрока, а параметры folder, ignore_slots, on_change, on_close в сторейдж игрока `container`.
## Создание страниц
Страница в  фреймворке это просто массив специальных предметов(смотрите ниже), такой же как, например, у бочки, расположенный в сторейдже gui:main. **Все предметы и компоненты на странице должны быть помечены тегом null:1b!**
## Создание кнопок
Для создания кнопок существуют теги link и commands.
### Тег link
Данный тег вызывает поведение смены параметров пути, то есть, если поместить ваши команды сюда, при нажатии на кнопку фреймворк будет пытаться сохранить и загружить контекст, также вы можете использовать сохранение страницы или возвращение к предыдущей с помощью команд:
```mcfunction
function gui:hooks/save_history

function gui:hooks/back
```
### Тег commands
Данный тег нужен для выполнения любых комманд не связанных с изменением параметров страницы.
## Немного о работе фреймворка
В процессе работы фреймворка каждый игрок получает счёт `ID`, с помощью которого к нему привязывается свой сторейдж. Все данные игроков хранятся в сторейдже `gui:main gui_cash.ID`

Когда игрок открывает эндер сундук, запускается функция `gui:search/start`, в которой мы пытаемся найти маркер с тегом `gui` одним из двух способов: рейкаст или поиск сущности с помощью distance. С помощью некоторой id логики, мы можем отследить, что игрок открыл или закрыл gui. При открытии интерфейса запускается функция `gui:search/help/temp`, в которой с помощью макросов мы копируем сторейдж игрока `gui:main gui_cash.ID` в `gui:main container`, в него переносим все параметры из маркера,также запускаем команды из него, и затем, сторейдж `gui:main container` сохраняется обратно в `gui:main gui_cash.ID`. Также при первом открытии мы добавляем все сохранённые контексты если этого требуют параметры, загружаем страницу, используя функцию `gui:gui/refresh/mask`.

Далее каждый тик маркер будет получать тег active, и запускать функцию `gui:gui/tick`, в ней исполнение с помощью id переходит к игрокам, и с помощью макросов мы снова получаем сторейдж `gui:main container` со всеми данными игрока, который доступен везде далее, и сохраняется в игрока по окончанию всех процессов.

Итак, мы пытаемся скопировать содержимое эндер сундука в сторейдж `gui:main container.EnderItems`. Если нам это удалось запускается функция `gui:gui/refresh/main`. 

В ней мы говорим фреймворку убить все предметы, помеченные тегом `null:1b`.

Здесь мы записываем в переменную `#shift main_score` был ли предмет с тегом `null:1b` в инвентаре игрока,очищаем у игрока все предметы помеченные тегом `null:1b`, записывая в score `#buttons main_score`.

Копируем предметы эндер сундука в сторейдж `gui:main return` и удаляем все предметы, также помеченные тегом `null:1b`, оставшиеся предметы при надобности пропускаем через функцию, которая удалит все разрешённые тегом `ignore_slots` слоты из массива `return`, и создаст другой массив `gui:main container.save`. Если что-то осталось в массиве `return`, возвращаем предметы игроку через шалкер на координатах `0 -64 0`. 

Если счёт игрока `#buttons main_score` равен 1 и больше, обрабатываем кнопки. Для этого, вычисляем все предметы на странице: копируем все предметы из пути, загружаем компоненты если нужно. Из него вычитаем массив предметов эндер сундука игрока. Если оставшийся предмет имеет теги `link` или `commands` обрабатываем их с помощью цикла с макросами. Тег `link` перед этим запускает функцию `gui:gui/refresh/change_with_behavior`, в которой обрабатывается сохранение контекста.

После кнопок исполняется массив команд смены страницы `on_change`.

И наконец исполняется функция `gui:gui/refresh/mask`. В ней мы получаем предметы из нужного пути, добавляем массивы компонентов и положенных предметов.

Когда игрок выходит из эндер сундука мы больше не находим маркер и запускается функция `gui:search/help/temp`, в которой сохраняются контексты или возвращаются предметы, также запускается массив команд `on_close`.

Обобщённая схема всех процессов:

поиск → открытие → сравнение → возвращение → кнопки → загрузка → закрытие

## Примеры использования

